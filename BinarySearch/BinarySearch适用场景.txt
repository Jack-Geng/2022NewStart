按照leetcode的tag来做题，这段时间主要攻克binarySearch的问题

https://leetcode.com/problems/evaluate-boolean-binary-tree/
-------------------------------------------------------------------------------------------------------------
这道题目呢，怎么看也跟binarysearch挂不起来关系，充其量只能因为是有个binary在名字里，but anyway。

最终结果的算出，是要依赖于左右节点最后的结果，所以必须bottom up来计算，相当于后序遍历二叉树一样。

来思考下
模拟：模拟题目的运行。
规律：尝试总结出题目的一般规律和特点。
匹配：找到符合这些特点的数据结构与算法。
边界：考虑特殊情况

    OR                      OR                      True
True    And             True    False
    False   True --->                   -----> 

模拟题目的运行
题目里也是从底向上算，根据叶子节点来计算非叶子节点的结果，最后再得出最终结果

规律：尝试总结出题目的一般规律和特点。
每个非叶子节点的运算都是一样的，拿到左边节点的最终结果和右边结果的最终结果，然后执行运算。

如果你是叶子节点，那么0返回false，1返回true。
如果你是非叶子节点，2就执行or 运算， 3就执行and运算

匹配：找到符合这些特点的数据结构与算法。
对于bottom up的运算来说，递归是最好的方法，当然也可以非递归，我一会写一个
本题中递归的写法，就是二叉树的后序遍历， 左 右 中间

边界：考虑特殊情况
如果叶子节点，要怎么处理
如果传入的根节点就是叶子节点，你要如何处理

我们需要检查root == null么，不用，因为题目里明确的写着root不为空
我们需要检查叶子节点缺失的情况么，不用，因为这是一棵full binary tree，那就意味着 叶子节点是成对出现的。对于 n来讲，2n + 1 exist and 2n + 2 exist
-------------------------------------------------------------------------------------------------------------